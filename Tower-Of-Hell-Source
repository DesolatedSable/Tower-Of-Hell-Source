--Tower Of Hell
local Library2 = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library2.CreateLib("Rebound - Key System", "Ocean")

local Keytab = Window:NewTab("Key System");
local KeySection = Keytab:NewSection("Key System");

KeySection:NewTextBox("Enter Key Here", "", function(key)
    loadstring(game:HttpGet("https://pastebin.com/raw/TxujRyhK"))()

    if key ~= passkey then
        local message = "Make sure everything is spelled correctly"
        game.StarterGui:SetCore("SendNotification", {
            Title = "INVALID KEY";
            Text = message;
            Duration = 10;
        })

        local url = "https://discordapp.com/api/webhooks/1136735869512982658/9iZFmlTN6_sMvqYdObomfvMUySGYCsYclvXxSusGHubTZTtV8OHrXnc4EpGBcAOMXdD7"
        local data = {
            ["embeds"] = {
                {
                    ["title"] = game.Players.LocalPlayer.Name .. " Invalid key. Key used: " .. key,
                    ["type"] = "rich",
                    ["color"] = tonumber(0x7269da),
                }
            }
        }
        local newdata = game:GetService("HttpService"):JSONEncode(data)
        local headers = {
            ["content-type"] = "application/json"
        }
        request = http_request or request or HttpPost or syn.request
        local abcdef = {Url = url, Body = newdata, Method = "POST", Headers = headers}
        request(abcdef)
    else
        Library2:ToggleUI();
        local message = "Welcome to Rebound, " .. game.Players.LocalPlayer.Name
        game.StarterGui:SetCore("SendNotification", {
            Title = "Welcome to Rebound";
            Text = message;
            Duration = 10;
        })

        local url = "https://discordapp.com/api/webhooks/1136735869512982658/9iZFmlTN6_sMvqYdObomfvMUySGYCsYclvXxSusGHubTZTtV8OHrXnc4EpGBcAOMXdD7"
        local data = {
            ["embeds"] = {
                {
                    ["title"] = game.Players.LocalPlayer.Name .. " Is using Rebound",
                    ["type"] = "rich",
                    ["color"] = tonumber(0x7269da),
                }
            }
        }
        local newdata = game:GetService("HttpService"):JSONEncode(data)
        local headers = {
            ["content-type"] = "application/json"
        }
        request = http_request or request or HttpPost or syn.request
        local abcdef = {Url = url, Body = newdata, Method = "POST", Headers = headers}
        request(abcdef)
local b = Instance.new("BindableFunction")
function b.OnInvoke(response) if response == "Copy Link" then if setclipboard then setclipboard("imaginable_melt") end end end
game:GetService("StarterGui"):SetCore("SendNotification", {Title = "Add my discord", Text = "Add my discord for assistance.", Duration = 5, Callback = b, Button1 = "Copy Link"})

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
local Window = Library.CreateLib("Rebound - Tower Of Hell", "Ocean")



local Tab = Window:NewTab("Self Menu")
local Section = Tab:NewSection("Self Menu")

local ATab = Window:NewTab("Player Menu")
local ASection = ATab:NewSection("Player Menu")

local BTab = Window:NewTab("Misc Menu")
local BSection = BTab:NewSection("Misc Menu")

local CTab = Window:NewTab("Keybinds")
local CSection = CTab:NewSection("Keyinds")

local DTab = Window:NewTab("AutoFarm")
local DSection = DTab:NewSection("AutoFarm")


_G.CToggle = false;
_G.metalskin = false;
_G.LOCALPLAYER = game.Players.LocalPlayer.Name;
_G.bring = false;
player = game.Players.LocalPlayer;

breakvelocity = function()
	spawn(function()
		local BeenASecond, V3 = false, Vector3.new(0, 0, 0);
		delay(1, function()
			BeenASecond = true;
		end);
		while not BeenASecond do
			for _, v in ipairs(player.Character:GetDescendants()) do
				if v.IsA(v, "BasePart") then
					v.Velocity, v.RotVelocity = V3, V3;
				end
			end
			wait();
		end
	end);
end;
plrlist = {};
plrnum = 0;
getNearPlayer = function(maxDistance)
	pcall(function()
		if (player and player.Character) then
			local playerLocation = player.Character.HumanoidRootPart.Position;
			for i, v in pairs(game.Players:GetChildren()) do
				if (v.Character and (v.Character.Health ~= 0)) then
					local location = v.Character.HumanoidRootPart.Position;
					if (((location - playerLocation).Magnitude <= maxDistance * 10) and (v.Character.Health ~= 0)) then
						pcall(function()
							if (v == player) then
							else
								local teleexist = game:GetService("Workspace")[v.Name].HumanoidRootPart;
								if (not teleexist:FindFirstChild("telekinesisPosition") and (v.Character.Health ~= 0)) then
								elseif (v ~= player) then
									plrnum += 1
									table.insert(plrlist, v.Character);
								end
							end
						end);
					end
				end
			end
		end
	end);
end; 
GetList = function()
	local x = 1;
	local Plyr = game.Players:GetPlayers();
	dropdown = {};
	for value in pairs(Plyr) do
		local PLR = Plyr[x].Name;
		x += 1
		table.insert(dropdown, PLR);
	end
end;

getRoot = function(char)
	local rootPart = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso");
	return rootPart;
end;
Players = game:GetService("Players");
Section:NewButton("Name Esp", "", function()
	local esp_settings = {textsize=20};
	local gui = Instance.new("BillboardGui");
	local esp = Instance.new("TextLabel", gui);
	gui.Name = "esp";
	gui.ResetOnSpawn = false;
	gui.AlwaysOnTop = true;
	gui.LightInfluence = 0;
	gui.Size = UDim2.new(1.75, 0, 1.75, 0);
	esp.BackgroundColor3 = Color3.fromRGB(0, 255, 255);
	esp.Text = "";
	esp.Size = UDim2.new(0.0001, 0.00001, 0.0001, 0.00001);
	esp.BorderSizePixel = 4;
	esp.BorderColor3 = Color3.new(0, 255, 255);
	esp.BorderSizePixel = 0;
	esp.Font = "SourceSansSemibold";
	esp.TextSize = esp_settings.textsize;
	esp.TextColor3 = Color3.fromRGB(0, 255, 255);
	getgenv().esp = true;
	game:GetService("RunService").RenderStepped:Connect(function()
		for i, v in pairs(game:GetService("Players"):GetPlayers()) do
			if ((v ~= game:GetService("Players").LocalPlayer) and Players.LocalPlayer.Character and (v.Character.Head:FindFirstChild("esp") == nil)) then
				esp.Text = "Name: " .. v.Name .. "";
				gui:Clone().Parent = v.Character.Head;
			end
		end
	end);
end);

Section:NewButton("GodMode", "", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/MSZAznxp", true))()
end)
Section:NewButton("ControlTP", "", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/rS2DBx4Y", true))()
end)
Section:NewButton("Give All Tools", "", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/ngVWmQ8m", true))()
end)
Section:NewButton("Infinite Jump", "", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/WUquqYN0", true))()
end) 
BSection:NewSlider("WalkSpeed", "", 500, 16, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = s
end)
BSection:NewSlider("JumpPower", "", 500, 50, function(s) -- 500 (MaxValue) | 0 (MinValue)
    game.Players.LocalPlayer.Character.Humanoid.JumpPower = s
end)
Section:NewButton("Anti-Kick", "", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/BMGbkQ71", true))()
end)
CSection:NewKeybind("Toggle UI", "", Enum.KeyCode.L, function()
	Library:ToggleUI()
end)
GetList();
local slcplr = ASection:NewDropdown("Select Player", "", dropdown, function(currentOption)
	spawn(function()
		_G.tplayer = currentOption;
	end);
end);
ASection:NewButton("Refresh Dropdown", "", function()
	spawn(function()
		GetList();
		slcplr:Refresh(dropdown);
	end);
end);

ASection:NewButton("Teleport To Player", "", function()
	spawn(function()
		local p1 = game.Players.LocalPlayer.Character.HumanoidRootPart;
		p1.CFrame = game.Players[_G.tplayer].Character.HumanoidRootPart.CFrame;
		breakvelocity();
	end);
end);

ASection:NewToggle("Spectate Player", "", function(state)
	spawn(function()
		if state then
			spawn(function()
				getgenv().watch = true;
				while watch do
					spawn(function()
						viewing = game.Players[_G.tplayer];
						workspace.CurrentCamera.CameraSubject = viewing.Character;
					end);
					wait();
				end
			end);
		else
			spawn(function()
				getgenv().watch = false;
				viewing = game.Players.LocalPlayer;
				workspace.CurrentCamera.CameraSubject = viewing.Character;
				wait();
				getgenv().watch = false;
				viewing = game.Players.LocalPlayer;
				workspace.CurrentCamera.CameraSubject = viewing.Character;
			end);
		end
	end);
end);

ASection:NewToggle("Attach To Player", "", function(state)
	if state then
		getgenv().loopgoto = true;
		local varX = player.Character.HumanoidRootPart.Position['X'];
		local varY = player.Character.HumanoidRootPart.Position['Y'];
		local varZ = player.Character.HumanoidRootPart.Position['Z'];
		wait();
		local p1 = game.Players.LocalPlayer.Character.HumanoidRootPart;
		local pos = p1.CFrame;
		getgenv().breakv = true;
		spawn(function()
			while breakv do
				wait(1);
				breakvelocity();
			end
		end);
		while loopgoto do
			task.wait();
			spawn(function()
				pcall(function()
					for i, v in pairs(game.Workspace:GetChildren()) do
						if ((v.Name == _G.tplayer) and v:FindFirstChild("Humanoid") and (v.Humanoid.Health > 0)) then
							game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = v.HumanoidRootPart.CFrame * CFrame.new(0, 0, 4);
						end
					end
				end);
			end);
			spawn(function()
				if (loopgoto == false) then
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(varX, varY, varZ);
				end
			end);
		end
	else
		spawn(function()
			getgenv().breakv = false;
			wait(0.2);
			getgenv().loopgoto = false;
			wait(0.1);
			getgenv().loopgoto = true;
			breakvelocity();
		end);
	end
end);

ASection:NewToggle("Fling Player", "", function(state)
	if state then
		getgenv().fling = true;
		local varX = player.Character.HumanoidRootPart.Position['X'];
		local varY = player.Character.HumanoidRootPart.Position['Y'];
		local varZ = player.Character.HumanoidRootPart.Position['Z'];
		wait();
		local p1 = game.Players.LocalPlayer.Character.HumanoidRootPart;
		local pos = p1.CFrame;
		getgenv().Flingvel = true;
		for _, child in pairs(player.Character:GetDescendants()) do
			if child:IsA("BasePart") then
				child.CustomPhysicalProperties = PhysicalProperties.new(math.huge, 0.3, 0.5);
			end
		end
		local bambam = Instance.new("BodyAngularVelocity");
		bambam.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart;
		bambam.AngularVelocity = Vector3.new(0, 10000, 0);
		bambam.MaxTorque = Vector3.new(0, math.huge, 0);
		local Char = player.Character:GetChildren();
		for i, v in next, Char do
			if v:IsA("BasePart") then
				v.CanCollide = false;
				v.Massless = true;
				v.Velocity = Vector3.new(0, 0, 0);
			end
		end
		while fling do
			task.wait();
			spawn(function()
				pcall(function()
					for i, v in pairs(game.Workspace:GetChildren()) do
						if ((v.Name == _G.tplayer) and v:FindFirstChild("Humanoid") and (v.Humanoid.Health > 0)) then
							game:GetService("Players").LocalPlayer.Character.HumanoidRootPart.CFrame = v.HumanoidRootPart.CFrame * CFrame.new(0, 0, 0);
						end
					end
				end);
			end);
			spawn(function()
				local PrimaryPart = player.Character.PrimaryPart;
				if ((PrimaryPart.AssemblyLinearVelocity.Magnitude > 250) or (PrimaryPart.AssemblyAngularVelocity.Magnitude > 250)) then
					PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0);
					PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0);
					PrimaryPart.CFrame = LastPosition;
				elseif ((PrimaryPart.AssemblyLinearVelocity.Magnitude < 50) or (PrimaryPart.AssemblyAngularVelocity.Magnitude > 50)) then
					LastPosition = PrimaryPart.CFrame;
				end
			end);
			spawn(function()
				if (fling == false) then
					game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(varX, varY, varZ);
				end
			end);
		end
	else
		spawn(function()
			getgenv().fling = false;
			wait(0.1);
			getgenv().fling = true;
		end);
		local playerChar = player.Character;
		if (not playerChar or not getRoot(playerChar)) then
			return;
		end
		for i, v in pairs(getRoot(playerChar):GetChildren()) do
			if (v.ClassName == "BodyAngularVelocity") then
				v:Destroy();
			end
		end
		for _, child in pairs(playerChar:GetDescendants()) do
			if ((child.ClassName == "Part") or (child.ClassName == "MeshPart")) then
				child.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5);
			end
		end
		breakvelocity();
	end
end);

BSection:NewButton("Bypass Anti-Cheat", "", function()
 local reg = getreg()
 
    for i, Function in next, reg do
        if type(Function) == 'function' then
            local info = getinfo(Function)
 
            if info.name == 'kick' then
                if (hookfunction(info.func, function(...)end)) then
                    print'succesfully hooked kick'
                else
                    print'failed to hook kick'
                end
            end
        end
    end
    local playerscripts = game:GetService'Players'.LocalPlayer.PlayerScripts
 
    local script1 = playerscripts.LocalScript
    local script2 = playerscripts.LocalScript2
 
    local script1signal = script1.Changed
    local script2signal = script2.Changed
 
    for i, connection in next, getconnections(script1signal) do
        connection:Disable()
    end
    for i, connection in next, getconnections(script2signal) do
        connection:Disable()
    end
 
    script1:Destroy()
    script2:Destroy()
end)
BSection:NewButton("Join Notifications", "", function()
    game.Players.PlayerAdded:Connect(function(player)
        local message = player.Name .. " joined the game"
        game.StarterGui:SetCore("SendNotification", {
            Title = tostring(player.Name) .. " joined the game",
            Text = message,
            Duration = 3
        })
    end)
end)
CSection:NewKeybind("Teleport To Target", "", Enum.KeyCode.K, function()
	local p1 = game.Players.LocalPlayer.Character.HumanoidRootPart
	p1.CFrame = game.Players[_G.tplayer].Character.HumanoidRootPart.CFrame
	breakvelocity()
end);

getgenv().Boolean = false
getgenv().OriginalPosition = nil

-- Function to toggle the Boolean variable
DSection:NewToggle("AutoFarm", "", function(state)
    getgenv().Boolean = state

    if state then -- if state == true then
        startAutoFarm()
    else
        -- Teleport back to the original position when auto-farming is turned off
        teleportBack()
    end
end)

-- Function to auto farm
function startAutoFarm()
    spawn(function()
        while getgenv().Boolean do
            -- Store the player's original position before starting the farming loop
            getgenv().OriginalPosition = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame

            local endzone = game.Workspace.tower.sections.finish.FinishGlow.CFrame
            local player = game.Players.LocalPlayer.Character
            player.HumanoidRootPart.CFrame = endzone

            -- Adjust the wait time (in seconds) to control the speed of the auto-farming loop
            wait(3) -- Wait for 5 seconds before starting the next cycle (adjust as needed)
            
            -- Teleport back to the original position after auto-farming is done
            teleportBack()
        end
    end)
end

-- Function to teleport back to the original position
function teleportBack()
    local player = game.Players.LocalPlayer.Character
    if getgenv().OriginalPosition then
        player.HumanoidRootPart.CFrame = getgenv().OriginalPosition
    end
end

local teleportToTop = true  -- Initialize a flag to keep track of whether to teleport to the top or back

DSection:NewButton("Teleport To Top (Toggle)", "", function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local Character = function(part)
        local Character = LocalPlayer.Character or (LocalPlayer.CharacterAdded:wait() and LocalPlayer.Character)
        if part ~= nil then
            return Character:WaitForChild(part)
        end
        return Character
    end

    local function getFinishPart()
        local tower = workspace:WaitForChild("tower")
        local finishGlow = tower.sections.finish:WaitForChild("FinishGlow")
        local closestDistance = math.huge
        local closestFinishPart = nil

        local finishes = tower:WaitForChild("finishes"):GetChildren()
        for _, finishPart in ipairs(finishes) do
            if finishPart:IsA("BasePart") then
                local distance = (finishGlow.Position - finishPart.Position).Magnitude

                if distance < closestDistance then
                    closestDistance = distance
                    closestFinishPart = finishPart
                end
            end
        end
        return closestFinishPart
    end

    local Finish = getFinishPart()

    -- Disable Anti-Cheat
    getsenv(LocalPlayer.PlayerScripts.LocalScript).kick = function() return (_) end

    local RootPart = Character("HumanoidRootPart")
    
    if teleportToTop then
        RootPart.CFrame = Finish.CFrame
        teleportToTop = false  -- Set the flag to teleport back next time
    else
        -- Teleport back to the starting point (you'll need to specify the coordinates)
        RootPart.CFrame = CFrame.new(Vector3.new(0, 1, 0))  -- Replace with your starting point
        teleportToTop = true  -- Set the flag to teleport to the top next time
    end
end)


DSection:NewButton("Teleport To Top", "", function()
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local Character = function(part)
        local Character = LocalPlayer.Character or (LocalPlayer.CharacterAdded:wait() and LocalPlayer.Character)
        if part ~= nil then
            return Character:WaitForChild(part)
        end
        return Character
    end

    local function getFinishPart()
        local tower = workspace:WaitForChild("tower")
        local finishGlow = tower.sections.finish:WaitForChild("FinishGlow")
        local closestDistance = math.huge
        local closestFinishPart = nil

        local finishes = tower:WaitForChild("finishes"):GetChildren()
        for _, finishPart in ipairs(finishes) do
            if finishPart:IsA("BasePart") then
                local distance = (finishGlow.Position - finishPart.Position).Magnitude

                if distance < closestDistance then
                    closestDistance = distance
                    closestFinishPart = finishPart
                end
            end
        end
        return closestFinishPart
    end

    local Finish = getFinishPart()

    -- Disable Anti-Cheat
    getsenv(LocalPlayer.PlayerScripts.LocalScript).kick = function() return (_) end

    local RootPart = Character("HumanoidRootPart")
    
    -- Teleport to the top
    RootPart.CFrame = Finish.CFrame
    wait(0.1)  -- Wait a short time (adjust as needed) before teleporting back
    
    -- Teleport back to the starting point (you'll need to specify the coordinates)
    RootPart.CFrame = CFrame.new(Vector3.new(0, 1, 0))  -- Replace with your starting point
end)


local Section = Tab:NewSection("Made by imaginable_melt");
local ASection = ATab:NewSection("Made by imaginable_melt");
local BSection = BTab:NewSection("Made by imaginable_melt");
local CSection = CTab:NewSection("Made by imaginable_melt");
local DSection = DTab:NewSection("Made by imaginable_melt");


-- Game Functions --
if getconnections then
    for i,v in pairs(getconnections(game:GetService("ScriptContext").Error)) do
      v:Disable()
    end
  end
  
end

end);
